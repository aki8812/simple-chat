<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>SimpleChat</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" href="favicon.ico" />
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <div class="brand" id="brandBtn">SimpleChat</div>
      <div class="userlist" id="userList"></div>
    </aside>

    <main class="main">
      <header class="topbar">
        <div class="left">
          <div id="verifyBanner" class="banner hidden">
            尚未完成 Email 驗證，驗證前無法發話。若未收到驗證信，請查看您的垃圾郵件。或者 - >
            <button id="resendVerify" class="linklike">重新寄送驗證信</button>
          </div>
          <div id="banBanner" class="banner hidden">你已被管理員封鎖，無法發話。</div>
        </div>
        <div class="right">
          <input id="newNickname" maxlength="24" placeholder="更改暱稱（3–24 字）" />
          <button id="saveNickname">更新</button>
          <button id="logout" class="danger">登出</button>
        </div>
      </header>

      <section id="messages" class="chat-box" aria-live="polite" aria-label="聊天訊息"></section>

      <div class="input-area">
        <input type="text" id="messageInput" placeholder="輸入訊息...（可 @暱稱）" autocomplete="off" />
        <button id="sendBtn" type="button">送出</button>
      </div>
    </main>
  </div>

  <!-- 使用者卡片 -->
  <div id="userCard" class="popup hidden"></div>

  <script type="module">
    import { auth, db } from './firebase.js';
    import { onAuthStateChanged, signOut, sendEmailVerification, reload } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js';
    import { ref, push, onChildAdded, query, orderByChild, limitToLast, endAt, get, onValue, remove, update, runTransaction, set } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js';

    // DOM Elements
    const messagesBox   = document.getElementById('messages');
    const inputEl       = document.getElementById('messageInput');
    const sendBtn       = document.getElementById('sendBtn');
    const userListEl    = document.getElementById('userList');
    const verifyBanner  = document.getElementById('verifyBanner');
    const banBanner     = document.getElementById('banBanner');
    const resendVerify  = document.getElementById('resendVerify');
    const newNickEl     = document.getElementById('newNickname');
    const saveNickBtn   = document.getElementById('saveNickname');
    const logoutBtn     = document.getElementById('logout');
    const userCard      = document.getElementById('userCard');
    const brandBtn      = document.getElementById('brandBtn');

    // App State
    let me = null;
    let myProfile = null;
    let isAdmin = false;

    const users = new Map();
    const adminsSet = new Set();
    const bansSet = new Set();
    const loadedMessages = new Map();

    // ===== Auth & Initialization =====
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = 'login.html';
        return;
      }
      me = user;
      try { await reload(me); } catch {}

      // Start listening to data changes
      initializeListeners();

      // Load initial messages
      const msgQuery = query(ref(db, 'messages'), orderByChild('time'), limitToLast(25));
      const msgSnap = await get(msgQuery);
      messagesBox.innerHTML = '';
      if (msgSnap.exists()) {
        msgSnap.forEach(snap => addMessage(snap.key, snap.val(), false));
      }
      onChildAdded(msgQuery, (snap) => addMessage(snap.key, snap.val(), false));
      
      messagesBox.scrollTop = messagesBox.scrollHeight;
      messagesBox.addEventListener('scroll', handleScroll);

      // Bind UI events
      sendBtn.addEventListener('click', sendMessage);
      inputEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendMessage(); }});
      logoutBtn.addEventListener('click', () => signOut(auth));
      resendVerify.addEventListener('click', resendVerificationEmail);
      saveNickBtn.addEventListener('click', changeNickname);
      brandBtn.addEventListener('click', () => location.reload());
    });

    function initializeListeners() {
      // ★ 核心監聽 #1：Admins - 這是所有管理員權限的唯一來源
      onValue(ref(db, 'admins'), (snap) => {
        adminsSet.clear();
        snap.forEach(ch => {
          // 確保值為 true
          if (ch.val() === true) {
            adminsSet.add(ch.key);
          }
        });
        isAdmin = adminsSet.has(me.uid);
        // 管理員列表變更後，強制重繪所有相關UI
        rerenderAllUIs();
      });

      // 監聽 Users - 用於顯示暱稱和列表
      onValue(ref(db, 'users'), (snap) => {
        users.clear();
        snap.forEach((u) => {
          const p = u.val()?.profile;
          if (p) users.set(u.key, p);
        });
        if (users.has(me.uid)) {
            myProfile = users.get(me.uid);
            newNickEl.value = myProfile.nickname || '';
        }
        rerenderAllUIs();
      });

      // 監聽 Bans - 用於控制發話權限
      onValue(ref(db, 'bans'), (snap) => {
        bansSet.clear();
        snap.forEach(ch => bansSet.add(ch.key));
        rerenderAllUIs();
      });
    }

    // ★ 統一重繪函式
    function rerenderAllUIs() {
        if (!me || !users.size) return;
        renderUserList();
        refreshControls();
        rerenderMessages(); // 重繪訊息，更新刪除按鈕狀態
    }

    function refreshControls() {
      const verified = !!me.emailVerified;
      const isBanned = bansSet.has(me.uid);
      verifyBanner.classList.toggle('hidden', verified);
      banBanner.classList.toggle('hidden', !isBanned);
      
      const hasNick = myProfile && myProfile.nickname;
      const disabled = !verified || isBanned || !hasNick;

      inputEl.disabled = disabled;
      sendBtn.disabled = disabled;
      inputEl.placeholder = disabled 
        ? (isBanned ? '您已被管理員封鎖' : (!verified ? '請先驗證 Email' : '請先設定暱稱'))
        : '輸入訊息...（可 @暱稱）';
    }

    // ===== Messages =====
    function addMessage(key, msg, prepend = false) {
      if (!msg || loadedMessages.has(key)) return;

      const messageElement = createMessageElement(key, msg);
      loadedMessages.set(key, { data: msg, element: messageElement });

      if (prepend) {
        const oldHeight = messagesBox.scrollHeight;
        messagesBox.insertBefore(messageElement, messagesBox.firstChild);
        messagesBox.scrollTop += messagesBox.scrollHeight - oldHeight;
      } else {
        const isAtBottom = messagesBox.scrollHeight - messagesBox.clientHeight <= messagesBox.scrollTop + 5;
        messagesBox.appendChild(messageElement);
        if (isAtBottom) {
          messagesBox.scrollTop = messagesBox.scrollHeight;
        }
      }
    }
    
    function createMessageElement(key, msg) {
        const isSelf = me && msg.uid === me.uid;
        const canDelete = me && (isSelf || isAdmin);

        const wrap = document.createElement('div');
        wrap.className = `chat-message ${isSelf ? 'self' : 'other'}`;
        wrap.dataset.msgId = key;
        
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        
        let deleteBtnHtml = '';
        if (canDelete) {
            deleteBtnHtml = `<button class="del-btn" data-key="${key}">刪除</button>`;
        }

        bubble.innerHTML = `
            <div class="bubble-head">
                <div class="bubble-name" data-uid="${msg.uid}">${msg.nickname || '...'}</div>
                ${deleteBtnHtml}
            </div>
            <div class="bubble-text">${renderWithMentions(msg.text)}</div>
            <div class="bubble-time">${fmt(new Date(msg.time))}</div>
        `;
        wrap.appendChild(bubble);
        return wrap;
    }

    // 重新渲染所有訊息（主要用於更新權限）
    function rerenderMessages() {
        loadedMessages.forEach(({ data, element }, key) => {
            const isSelf = me && data.uid === me.uid;
            const canDelete = me && (isSelf || isAdmin);
            const delBtn = element.querySelector('.del-btn');
            
            if (canDelete && !delBtn) {
                // 新增刪除按鈕
                const head = element.querySelector('.bubble-head');
                const btn = document.createElement('button');
                btn.className = 'del-btn';
                btn.textContent = '刪除';
                btn.dataset.key = key;
                head.appendChild(btn);
            } else if (!canDelete && delBtn) {
                // 移除刪除按鈕
                delBtn.remove();
            }
        });
    }

    messagesBox.addEventListener('click', e => {
        if (e.target.classList.contains('del-btn')) {
            const key = e.target.dataset.key;
            if (confirm('確定要刪除此訊息？')) {
                remove(ref(db, `messages/${key}`)).catch(() => alert('刪除失敗'));
            }
        }
        if (e.target.classList.contains('bubble-name')) {
            openUserCard(e.target.dataset.uid);
        }
    });

    // ===== Nickname =====
    async function changeNickname() {
      if (!me) return;
      const newNick = (newNickEl.value || '').trim();
      if (newNick.length < 3 || newNick.length > 24) return alert('暱稱需 3–24 字');
      
      const lower = newNick.toLowerCase();
      const oldLower = (myProfile?.nicknameLower || '');

      if(lower === oldLower) return alert('新舊暱稱相同');

      try {
        const res = await runTransaction(ref(db, `nicknames/${lower}`), (cur) => (cur === null || cur === me.uid) ? me.uid : undefined);
        if (!res.committed) return alert('暱稱已被使用，請換一個');

        await update(ref(db, `users/${me.uid}/profile`), { nickname: newNick, nicknameLower: lower });
        if (oldLower) await set(ref(db, `nicknames/${oldLower}`), null);
        
        alert('已更新暱稱');
      } catch (e) { alert('更新失敗，請稍後再試'); }
    }

    // ===== User List & Card =====
    function renderUserList() {
      const arr = Array.from(users.values()).map(p => ({ ...p }));
      arr.sort((a,b) => (a.nickname || '').localeCompare(b.nickname || '', 'zh-Hant'));
      
      userListEl.innerHTML = arr.map(u => {
        const isMe = me && u.uid === me.uid;
        const isAdm = adminsSet.has(u.uid);
        const isBan = bansSet.has(u.uid);
        const classes = ['userrow', isMe && 'me', isAdm && 'admin', isBan && 'banned'].filter(Boolean).join(' ');
        const label = isAdm ? ' <span class="tag-admin">[管理員]</span>' : '';
        return `<div class="${classes}" data-uid="${u.uid}">@${u.nickname || '未命名'}${label}</div>`;
      }).join('');
      
      userListEl.querySelectorAll('.userrow').forEach(el => el.addEventListener('click', () => openUserCard(el.dataset.uid)));
    }

    function openUserCard(uid) {
        const p = users.get(uid); if (!p) return;
        const isMe = me && uid === me.uid;
        const canManage = isAdmin && !isMe;
        const isTargetBanned = bansSet.has(uid);
        
        userCard.innerHTML = `
        <div class="user-card">
          <div class="card-info">
            <div class="card-name">@${p.nickname} ${adminsSet.has(uid) ? '<span class="tag-admin" style="font-size:12px;">[管理員]</span>' : ''}</div>
            <div class="card-registered">註冊時間：${fmt(p.registeredAt)}</div>
            ${canManage ? `<div style="margin-top:10px"><button id="banBtn" class="${isTargetBanned ? '' : 'danger'}">${isTargetBanned ? '解封鎖' : '封鎖此用戶'}</button></div>` : ''}
            <div style="margin-top:10px"><button id="closeCard">關閉</button></div>
          </div>
        </div>`;
        userCard.classList.remove('hidden');
        document.getElementById('closeCard').onclick = () => userCard.classList.add('hidden');
        
        const banBtn = document.getElementById('banBtn');
        if (banBtn) banBtn.onclick = async () => {
          if (!confirm(isTargetBanned ? '確定要解封此用戶？' : '確定封鎖此用戶？')) return;
          try { 
            await (isTargetBanned ? remove(ref(db, `bans/${uid}`)) : set(ref(db, `bans/${uid}`), true));
            alert(isTargetBanned ? '已解封' : '已封鎖');
            userCard.classList.add('hidden');
          } catch { alert('操作失敗'); }
        };
    }
    
    // ===== Helpers =====
    async function resendVerificationEmail() {
        try { await sendEmailVerification(me); alert('已重新寄出驗證信。'); } catch(e) { alert('寄送失敗，可能寄送太頻繁。'); }
    }

    function handleScroll() { /* ... 捲動載入更多 ... */ }
    function renderWithMentions(text) { /* ... 提及 ... */ }
    function fmt(ts) { /* ... 時間格式 ... */ }
    
    // 把 helper 函式實作補上
    function fmt(ts) {
      if (typeof ts === 'number' && isFinite(ts)) return new Date(ts).toLocaleString();
      return '—';
    }
    
    function renderWithMentions(text) {
      if (!text) return '';
      const names = new Set(Array.from(users.values()).map(u => u.nickname).filter(Boolean));
      const escapedText = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return escapedText.replace(/(^|\s)@([\p{L}\p{N}_-]{3,24})/gu, (m, sp, name) => 
        names.has(name) ? `${sp}<span class="mention">@${name}</span>` : m
      );
    }
    
    async function handleScroll() {
        if (messagesBox.scrollTop > 20) return;
        const firstMsgEl = messagesBox.querySelector('.chat-message');
        if (!firstMsgEl) return;
        const firstMsgKey = firstMsgEl.dataset.msgId;
        const firstMsgTime = loadedMessages.get(firstMsgKey)?.data.time;
        if (!firstMsgTime) return;

        const moreQ = query(ref(db, 'messages'), orderByChild('time'), endAt(firstMsgTime - 1), limitToLast(25));
        const snap = await get(moreQ);
        if (snap.exists()) {
            const messages = [];
            snap.forEach(s => messages.push({ key: s.key, val: s.val() }));
            messages.reverse().forEach(m => addMessage(m.key, m.val, true));
        }
    }

  </script>
</body>
</html>